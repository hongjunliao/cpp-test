// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_AAPP_PROT_H_INCLUDED__
#define __RPCC_AAPP_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"

enum ip_vers_t {
  IP_V4 = 4,
};
void *ip_vers_t_alloc ();
bool_t xdr_ip_vers_t (XDR *, void *);
RPC_ENUM_DECL (ip_vers_t)
TYPE2STRUCT( , ip_vers_t);

template<class T> inline bool
rpc_traverse (T &t, ip_vers_t &obj, const char *field = NULL)
{
  u_int32_t val = obj;
  bool ret = true;
  rpc_enter_field (t, field);
  if (!rpc_traverse (t, val)) {
    ret = false;
  } else {
    obj = ip_vers_t (val);
  }
  rpc_exit_field (t, field);
  return ret;
}


struct x_ip_addr_t {
  const ip_vers_t vers;
  union {
    union_entry_base _base;
    union_entry<u_int32_t> v4;
  };

#define rpcunion_tag_x_ip_addr_t vers
#define rpcunion_switch_x_ip_addr_t(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case IP_V4: \
    action (u_int32_t, v4); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  x_ip_addr_t (ip_vers_t _tag = (ip_vers_t) 0) : vers (_tag)
    { _base.init (); set_vers (_tag); }
  x_ip_addr_t (const x_ip_addr_t &_s)
    : vers (_s.vers)
    { _base.init (_s._base); }
  ~x_ip_addr_t () { _base.destroy (); }
  x_ip_addr_t &operator= (const x_ip_addr_t &_s) {
    const_cast<ip_vers_t &> (vers) = _s.vers;
    _base.assign (_s._base);
    return *this;
  }

  void set_vers (ip_vers_t _tag) {
    const_cast<ip_vers_t &> (vers) = _tag;
    rpcunion_switch_x_ip_addr_t
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, x_ip_addr_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ip_vers_t tag = obj.vers;
  if (!rpc_traverse (t, tag, "vers")) { 
    ret = false;
  } else {
    if (tag != obj.vers)
      obj.set_vers (tag);

    rpcunion_switch_x_ip_addr_t
      (obj.vers, ret = RPCUNION_TRAVERSE_2, ret = true, ret = false);
    /* gcc 4.0.3 makes buggy warnings without the following.. */
  }
  rpc_exit_field (t, field);
  return ret;
}
inline bool
rpc_traverse (const stompcast_t &s, x_ip_addr_t &obj, const char *field = NULL)
{
  rpcunion_switch_x_ip_addr_t
    (obj.vers, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *x_ip_addr_t_alloc ();
bool_t xdr_x_ip_addr_t (XDR *, void *);
RPC_UNION_DECL (x_ip_addr_t)



struct x_host_addr_t {
  x_ip_addr_t ip_addr;
  u_int32_t port;
};
void *x_host_addr_t_alloc ();
bool_t xdr_x_host_addr_t (XDR *, void *);
RPC_STRUCT_DECL (x_host_addr_t)

template<class T> bool
rpc_traverse (T &t, x_host_addr_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.ip_addr, "ip_addr")
    && rpc_traverse (t, obj.port, "port");
  rpc_exit_field (t, field);
  return ret;
}



struct aapp_newcon_t {
  x_host_addr_t addr;
};
void *aapp_newcon_t_alloc ();
bool_t xdr_aapp_newcon_t (XDR *, void *);
RPC_STRUCT_DECL (aapp_newcon_t)

template<class T> inline bool
rpc_traverse (T &t, aapp_newcon_t &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.addr, "addr");
  rpc_exit_field (t, field);
  return ret;
}


enum aapp_status_t {
  AAPP_OK = 0,
  AAPP_BAD_FD = 1,
  AAPP_ERR = 2,
};
void *aapp_status_t_alloc ();
bool_t xdr_aapp_status_t (XDR *, void *);
RPC_ENUM_DECL (aapp_status_t)
TYPE2STRUCT( , aapp_status_t);

template<class T> inline bool
rpc_traverse (T &t, aapp_status_t &obj, const char *field = NULL)
{
  u_int32_t val = obj;
  bool ret = true;
  rpc_enter_field (t, field);
  if (!rpc_traverse (t, val)) {
    ret = false;
  } else {
    obj = aapp_status_t (val);
  }
  rpc_exit_field (t, field);
  return ret;
}

typedef rpc_str<RPC_INFINITY> logline_t;
void *logline_t_alloc ();
bool_t xdr_logline_t (XDR *, void *);
RPC_TYPEDEF_DECL (logline_t)

#ifndef AAPP_SERVER_PROG
#define AAPP_SERVER_PROG 5402
#endif /* !AAPP_SERVER_PROG */
extern const rpc_program aapp_server_prog_1;
enum { APP_SERVER_VERS = 1 };
enum {
  AAPP_SERVER_NULL = 0,
  AAPP_SERVER_NEWCON = 1,
};
#define AAPP_SERVER_PROG_1_APPLY_NOVOID(macro, void) \
  macro (AAPP_SERVER_NULL, void, void) \
  macro (AAPP_SERVER_NEWCON, aapp_newcon_t, aapp_status_t)
#define AAPP_SERVER_PROG_1_APPLY(macro) \
  AAPP_SERVER_PROG_1_APPLY_NOVOID(macro, void)

#ifndef LOGGER_PROG
#define LOGGER_PROG 5403
#endif /* !LOGGER_PROG */
extern const rpc_program logger_prog_1;
enum { LOGGER_VERS = 1 };
enum {
  LOGGER_NULL = 0,
  LOGGER_LOG = 1,
  LOGGER_TURN = 2,
};
#define LOGGER_PROG_1_APPLY_NOVOID(macro, void) \
  macro (LOGGER_NULL, void, void) \
  macro (LOGGER_LOG, logline_t, bool) \
  macro (LOGGER_TURN, void, bool)
#define LOGGER_PROG_1_APPLY(macro) \
  LOGGER_PROG_1_APPLY_NOVOID(macro, void)

namespace RPC {
  namespace aapp_server_prog_1 {

    // AAPP_SERVER_NULL -----------------------------------------

    template<class C, class E> void
    aapp_server_null(C c, E cb)
    { c->call (AAPP_SERVER_NULL, NULL, NULL, cb); }

    template<class E> void
    w_aapp_server_null(typename callback<void,rpc_bundle_t,E>::ref c, E cb)
    { (*c) ( rpc_bundle_t (AAPP_SERVER_NULL, NULL, NULL), cb); }

    template<class R, class E> R
    w_aapp_server_null(typename callback<R,rpc_bundle_t,E>::ref c, E cb)
    { return (*c) ( rpc_bundle_t (AAPP_SERVER_NULL, NULL, NULL), cb); }

    template<class S>
    class aapp_server_null_srv_t {
    public:
      aapp_server_null_srv_t(S *s) : _replied (false), _sbp (s) {}
      void reply () { check_reply (); _sbp->reply (NULL); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef void arg_ty;

      typedef void res_ty;

      template<class C, class E> void
      call_full(C c, const void *arg, void *res, E cb)
      { c->call (AAPP_SERVER_NULL, arg, res, cb); }

      template<class C, class E>
      void call(C c,  E cb)
      { aapp_server_null(c,  cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // AAPP_SERVER_NEWCON -----------------------------------------

    template<class C, class E> void
    aapp_server_newcon(C c, const aapp_newcon_t *arg, aapp_status_t *res, E cb)
    { c->call (AAPP_SERVER_NEWCON, arg, res, cb); }

    template<class C, class E> void
    aapp_server_newcon(C c, const aapp_newcon_t &arg, aapp_status_t *res, E cb)
    { c->call (AAPP_SERVER_NEWCON, &arg, res, cb); }

    template<class E> void
    w_aapp_server_newcon(typename callback<void,rpc_bundle_t,E>::ref c, const aapp_newcon_t *arg, aapp_status_t *res, E cb)
    { (*c) ( rpc_bundle_t (AAPP_SERVER_NEWCON, arg, res), cb); }

    template<class E> void
    w_aapp_server_newcon(typename callback<void,rpc_bundle_t,E>::ref c, const aapp_newcon_t &arg, aapp_status_t *res, E cb)
    { (*c) ( rpc_bundle_t (AAPP_SERVER_NEWCON, &arg, res), cb); }

    template<class R, class E> R
    w_aapp_server_newcon(typename callback<R,rpc_bundle_t,E>::ref c, const aapp_newcon_t *arg, aapp_status_t *res, E cb)
    { return (*c) ( rpc_bundle_t (AAPP_SERVER_NEWCON, arg, res), cb); }

    template<class R, class E> R
    w_aapp_server_newcon(typename callback<R,rpc_bundle_t,E>::ref c, const aapp_newcon_t &arg, aapp_status_t *res, E cb)
    { return (*c) ( rpc_bundle_t (AAPP_SERVER_NEWCON, &arg, res), cb); }

    template<class S>
    class aapp_server_newcon_srv_t {
    public:
      aapp_server_newcon_srv_t(S *s) : _replied (false), _sbp (s) {}
      const ::aapp_newcon_t* getarg() const {  return static_cast<aapp_newcon_t*> (_sbp->getvoidarg ()); }
      ::aapp_newcon_t* getarg() {  return static_cast<aapp_newcon_t*> (_sbp->getvoidarg ()); }
      void reply (const ::aapp_status_t *r) { check_reply (); _sbp->reply (r); }
      void reply (const ::aapp_status_t &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< ::aapp_status_t> r) { check_reply (); _sbp->reply (r); }
      ptr<aapp_status_t> alloc_res ()  { return New refcounted<aapp_status_t> (); }
      template<class T> ptr<aapp_status_t>
      alloc_res (const T &t)  { return New refcounted<aapp_status_t> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef aapp_newcon_t arg_ty;

      typedef aapp_status_t res_ty;

      template<class C, class E> void
      call_full(C c, const aapp_newcon_t *arg, aapp_status_t *res, E cb)
      { c->call (AAPP_SERVER_NEWCON, arg, res, cb); }

      template<class C, class E>
      void call(C c, const aapp_newcon_t* arg, aapp_status_t* res, E cb)
      { aapp_server_newcon(c, arg, res, cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };

  };
  namespace logger_prog_1 {

    // LOGGER_NULL -----------------------------------------

    template<class C, class E> void
    logger_null(C c, E cb)
    { c->call (LOGGER_NULL, NULL, NULL, cb); }

    template<class E> void
    w_logger_null(typename callback<void,rpc_bundle_t,E>::ref c, E cb)
    { (*c) ( rpc_bundle_t (LOGGER_NULL, NULL, NULL), cb); }

    template<class R, class E> R
    w_logger_null(typename callback<R,rpc_bundle_t,E>::ref c, E cb)
    { return (*c) ( rpc_bundle_t (LOGGER_NULL, NULL, NULL), cb); }

    template<class S>
    class logger_null_srv_t {
    public:
      logger_null_srv_t(S *s) : _replied (false), _sbp (s) {}
      void reply () { check_reply (); _sbp->reply (NULL); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef void arg_ty;

      typedef void res_ty;

      template<class C, class E> void
      call_full(C c, const void *arg, void *res, E cb)
      { c->call (LOGGER_NULL, arg, res, cb); }

      template<class C, class E>
      void call(C c,  E cb)
      { logger_null(c,  cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // LOGGER_LOG -----------------------------------------

    template<class C, class E> void
    logger_log(C c, const logline_t *arg, bool *res, E cb)
    { c->call (LOGGER_LOG, arg, res, cb); }

    template<class C, class E> void
    logger_log(C c, const logline_t &arg, bool *res, E cb)
    { c->call (LOGGER_LOG, &arg, res, cb); }

    template<class E> void
    w_logger_log(typename callback<void,rpc_bundle_t,E>::ref c, const logline_t *arg, bool *res, E cb)
    { (*c) ( rpc_bundle_t (LOGGER_LOG, arg, res), cb); }

    template<class E> void
    w_logger_log(typename callback<void,rpc_bundle_t,E>::ref c, const logline_t &arg, bool *res, E cb)
    { (*c) ( rpc_bundle_t (LOGGER_LOG, &arg, res), cb); }

    template<class R, class E> R
    w_logger_log(typename callback<R,rpc_bundle_t,E>::ref c, const logline_t *arg, bool *res, E cb)
    { return (*c) ( rpc_bundle_t (LOGGER_LOG, arg, res), cb); }

    template<class R, class E> R
    w_logger_log(typename callback<R,rpc_bundle_t,E>::ref c, const logline_t &arg, bool *res, E cb)
    { return (*c) ( rpc_bundle_t (LOGGER_LOG, &arg, res), cb); }

    template<class S>
    class logger_log_srv_t {
    public:
      logger_log_srv_t(S *s) : _replied (false), _sbp (s) {}
      const ::logline_t* getarg() const {  return static_cast<logline_t*> (_sbp->getvoidarg ()); }
      ::logline_t* getarg() {  return static_cast<logline_t*> (_sbp->getvoidarg ()); }
      void reply (const bool *r) { check_reply (); _sbp->reply (r); }
      void reply (const bool &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< bool> r) { check_reply (); _sbp->reply (r); }
      ptr<bool> alloc_res ()  { return New refcounted<bool> (); }
      template<class T> ptr<bool>
      alloc_res (const T &t)  { return New refcounted<bool> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef logline_t arg_ty;

      typedef bool res_ty;

      template<class C, class E> void
      call_full(C c, const logline_t *arg, bool *res, E cb)
      { c->call (LOGGER_LOG, arg, res, cb); }

      template<class C, class E>
      void call(C c, const logline_t* arg, bool* res, E cb)
      { logger_log(c, arg, res, cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };


    // LOGGER_TURN -----------------------------------------

    template<class C, class E> void
    logger_turn(C c, bool *res, E cb)
    { c->call (LOGGER_TURN, NULL, res, cb); }

    template<class E> void
    w_logger_turn(typename callback<void,rpc_bundle_t,E>::ref c, bool *res, E cb)
    { (*c) ( rpc_bundle_t (LOGGER_TURN, NULL, res), cb); }

    template<class R, class E> R
    w_logger_turn(typename callback<R,rpc_bundle_t,E>::ref c, bool *res, E cb)
    { return (*c) ( rpc_bundle_t (LOGGER_TURN, NULL, res), cb); }

    template<class S>
    class logger_turn_srv_t {
    public:
      logger_turn_srv_t(S *s) : _replied (false), _sbp (s) {}
      void reply (const bool *r) { check_reply (); _sbp->reply (r); }
      void reply (const bool &r) { check_reply (); _sbp->replyref (r); }
      void reply (ptr< bool> r) { check_reply (); _sbp->reply (r); }
      ptr<bool> alloc_res ()  { return New refcounted<bool> (); }
      template<class T> ptr<bool>
      alloc_res (const T &t)  { return New refcounted<bool> (t); }
      S *sbp () { return _sbp; }
      const S *sbp () const { return _sbp; }
      void reject (auth_stat s) { check_reply (); _sbp->reject (s); }
      void reject (accept_stat s) { check_reply (); _sbp->reject (s); }
      void reject () { check_reply (); _sbp->reject (); }

      typedef void arg_ty;

      typedef bool res_ty;

      template<class C, class E> void
      call_full(C c, const void *arg, bool *res, E cb)
      { c->call (LOGGER_TURN, arg, res, cb); }

      template<class C, class E>
      void call(C c,  bool* res, E cb)
      { logger_turn(c, res, cb); }

    private:
      void check_reply () { assert (!_replied); _replied = true; }
      bool _replied;
      S *_sbp;
    };

  };
};
/*
 *
 * MK note on RPC constant collection:
 *
 * The goal of this magic is to aggregate ALL of the RPC contants
 * in ALL of the .x files recursively included by your server
 * to be accessible at runtime to your server.  Thus, every
 * autogenerated .h protocol file will have one of these static
 * objects in it.  The static object itself doesn't do anything
 * other than call a constructor function, which in turn will
 * add this rpc_constant_collector_t hook (aapp_prot_constant_collect)
 * to a global list of hooks (see rpc_add_cch_t in extensible_arpc.C)
 *
 */
extern void aapp_prot_constant_collect (rpc_constant_collector_t *rcc);
static rpc_add_cch_t aapp_prot_obj (aapp_prot_constant_collect);

#endif /* !__RPCC_AAPP_PROT_H_INCLUDED__ */
