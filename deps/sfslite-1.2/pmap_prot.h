// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_PMAP_PROT_H_INCLUDED__
#define __RPCC_PMAP_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"

enum { PMAP_PORT = 111 };


struct mapping {
  u_int32_t prog;
  u_int32_t vers;
  u_int32_t prot;
  u_int32_t port;
};
void *mapping_alloc ();
bool_t xdr_mapping (XDR *, void *);
RPC_STRUCT_DECL (mapping)

template<class T> bool
rpc_traverse (T &t, mapping &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.prog, "prog")
    && rpc_traverse (t, obj.vers, "vers")
    && rpc_traverse (t, obj.prot, "prot")
    && rpc_traverse (t, obj.port, "port");
  rpc_exit_field (t, field);
  return ret;
}



struct pmaplist {
  mapping map;
  rpc_ptr<pmaplist> next;
};
void *pmaplist_alloc ();
bool_t xdr_pmaplist (XDR *, void *);
RPC_STRUCT_DECL (pmaplist)

template<class T> bool
rpc_traverse (T &t, pmaplist &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.map, "map")
    && rpc_traverse (t, obj.next, "next");
  rpc_exit_field (t, field);
  return ret;
}


typedef rpc_ptr<pmaplist> pmaplist_ptr;
void *pmaplist_ptr_alloc ();
bool_t xdr_pmaplist_ptr (XDR *, void *);
RPC_TYPEDEF_DECL (pmaplist_ptr)


struct call_args {
  u_int32_t prog;
  u_int32_t vers;
  u_int32_t proc;
  rpc_bytes<RPC_INFINITY> args;
};
void *call_args_alloc ();
bool_t xdr_call_args (XDR *, void *);
RPC_STRUCT_DECL (call_args)

template<class T> bool
rpc_traverse (T &t, call_args &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.prog, "prog")
    && rpc_traverse (t, obj.vers, "vers")
    && rpc_traverse (t, obj.proc, "proc")
    && rpc_traverse (t, obj.args, "args");
  rpc_exit_field (t, field);
  return ret;
}



struct call_result {
  u_int32_t port;
  rpc_bytes<RPC_INFINITY> res;
};
void *call_result_alloc ();
bool_t xdr_call_result (XDR *, void *);
RPC_STRUCT_DECL (call_result)

template<class T> bool
rpc_traverse (T &t, call_result &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.port, "port")
    && rpc_traverse (t, obj.res, "res");
  rpc_exit_field (t, field);
  return ret;
}


#ifndef PMAP_PROG
#define PMAP_PROG 100000
#endif /* !PMAP_PROG */
extern const rpc_program pmap_prog_2;
enum { PMAP_VERS = 2 };
enum {
  PMAPPROC_NULL = 0,
  PMAPPROC_SET = 1,
  PMAPPROC_UNSET = 2,
  PMAPPROC_GETPORT = 3,
  PMAPPROC_DUMP = 4,
  PMAPPROC_CALLIT = 5,
};
#define PMAP_PROG_2_APPLY_NOVOID(macro, void) \
  macro (PMAPPROC_NULL, void, void) \
  macro (PMAPPROC_SET, mapping, bool) \
  macro (PMAPPROC_UNSET, mapping, bool) \
  macro (PMAPPROC_GETPORT, mapping, u_int32_t) \
  macro (PMAPPROC_DUMP, void, pmaplist_ptr) \
  macro (PMAPPROC_CALLIT, call_args, call_result)
#define PMAP_PROG_2_APPLY(macro) \
  PMAP_PROG_2_APPLY_NOVOID(macro, void)

/*
 *
 * MK note on RPC constant collection:
 *
 * The goal of this magic is to aggregate ALL of the RPC contants
 * in ALL of the .x files recursively included by your server
 * to be accessible at runtime to your server.  Thus, every
 * autogenerated .h protocol file will have one of these static
 * objects in it.  The static object itself doesn't do anything
 * other than call a constructor function, which in turn will
 * add this rpc_constant_collector_t hook (pmap_prot_constant_collect)
 * to a global list of hooks (see rpc_add_cch_t in extensible_arpc.C)
 *
 */
extern void pmap_prot_constant_collect (rpc_constant_collector_t *rcc);
static rpc_add_cch_t pmap_prot_obj (pmap_prot_constant_collect);

#endif /* !__RPCC_PMAP_PROT_H_INCLUDED__ */
