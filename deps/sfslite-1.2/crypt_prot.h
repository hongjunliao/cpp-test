// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_CRYPT_PROT_H_INCLUDED__
#define __RPCC_CRYPT_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"
#include "bigint.h"

typedef rpc_opaque<20> _srp_hash;
void *_srp_hash_alloc ();
bool_t xdr__srp_hash (XDR *, void *);
RPC_TYPEDEF_DECL (_srp_hash)


struct srp_msg1 {
  rpc_str<RPC_INFINITY> salt;
  bigint N;
  bigint g;
};
void *srp_msg1_alloc ();
bool_t xdr_srp_msg1 (XDR *, void *);
RPC_STRUCT_DECL (srp_msg1)

template<class T> bool
rpc_traverse (T &t, srp_msg1 &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.salt, "salt")
    && rpc_traverse (t, obj.N, "N")
    && rpc_traverse (t, obj.g, "g");
  rpc_exit_field (t, field);
  return ret;
}



struct srp_msg2 {
  bigint A;
};
void *srp_msg2_alloc ();
bool_t xdr_srp_msg2 (XDR *, void *);
RPC_STRUCT_DECL (srp_msg2)

template<class T> inline bool
rpc_traverse (T &t, srp_msg2 &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.A, "A");
  rpc_exit_field (t, field);
  return ret;
}



struct srp_msg3 {
  bigint B;
  bigint u;
};
void *srp_msg3_alloc ();
bool_t xdr_srp_msg3 (XDR *, void *);
RPC_STRUCT_DECL (srp_msg3)

template<class T> bool
rpc_traverse (T &t, srp_msg3 &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.B, "B")
    && rpc_traverse (t, obj.u, "u");
  rpc_exit_field (t, field);
  return ret;
}



struct srp_msg4_src {
  _srp_hash sessid;
  bigint N;
  bigint g;
  rpc_str<RPC_INFINITY> user;
  rpc_str<RPC_INFINITY> salt;
  bigint A;
  bigint B;
  bigint S;
};
void *srp_msg4_src_alloc ();
bool_t xdr_srp_msg4_src (XDR *, void *);
RPC_STRUCT_DECL (srp_msg4_src)

template<class T> bool
rpc_traverse (T &t, srp_msg4_src &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.sessid, "sessid")
    && rpc_traverse (t, obj.N, "N")
    && rpc_traverse (t, obj.g, "g")
    && rpc_traverse (t, obj.user, "user")
    && rpc_traverse (t, obj.salt, "salt")
    && rpc_traverse (t, obj.A, "A")
    && rpc_traverse (t, obj.B, "B")
    && rpc_traverse (t, obj.S, "S");
  rpc_exit_field (t, field);
  return ret;
}



struct srp_msg5_src {
  _srp_hash sessid;
  bigint A;
  _srp_hash M;
  bigint S;
};
void *srp_msg5_src_alloc ();
bool_t xdr_srp_msg5_src (XDR *, void *);
RPC_STRUCT_DECL (srp_msg5_src)

template<class T> bool
rpc_traverse (T &t, srp_msg5_src &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.sessid, "sessid")
    && rpc_traverse (t, obj.A, "A")
    && rpc_traverse (t, obj.M, "M")
    && rpc_traverse (t, obj.S, "S");
  rpc_exit_field (t, field);
  return ret;
}


enum crypt_keytype {
  CRYPT_NOKEY = 0,
  CRYPT_RABIN = 1,
  CRYPT_2SCHNORR = 2,
  CRYPT_SCHNORR = 3,
  CRYPT_1SCHNORR = 4,
  CRYPT_ESIGN = 5,
  CRYPT_PAILLIER = 6,
  CRYPT_ELGAMAL = 7,
};
void *crypt_keytype_alloc ();
bool_t xdr_crypt_keytype (XDR *, void *);
RPC_ENUM_DECL (crypt_keytype)
TYPE2STRUCT( , crypt_keytype);

template<class T> inline bool
rpc_traverse (T &t, crypt_keytype &obj, const char *field = NULL)
{
  u_int32_t val = obj;
  bool ret = true;
  rpc_enter_field (t, field);
  if (!rpc_traverse (t, val)) {
    ret = false;
  } else {
    obj = crypt_keytype (val);
  }
  rpc_exit_field (t, field);
  return ret;
}


struct elgamal_ctext {
  bigint r;
  bigint m;
};
void *elgamal_ctext_alloc ();
bool_t xdr_elgamal_ctext (XDR *, void *);
RPC_STRUCT_DECL (elgamal_ctext)

template<class T> bool
rpc_traverse (T &t, elgamal_ctext &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  ret = rpc_traverse (t, obj.r, "r")
    && rpc_traverse (t, obj.m, "m");
  rpc_exit_field (t, field);
  return ret;
}



struct crypt_ctext {
  const crypt_keytype type;
  union {
    union_entry_base _base;
    union_entry<bigint> rabin;
    union_entry<bigint> paillier;
    union_entry<elgamal_ctext> elgamal;
  };

#define rpcunion_tag_crypt_ctext type
#define rpcunion_switch_crypt_ctext(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case CRYPT_RABIN: \
    action (bigint, rabin); \
    break; \
  case CRYPT_PAILLIER: \
    action (bigint, paillier); \
    break; \
  case CRYPT_ELGAMAL: \
    action (elgamal_ctext, elgamal); \
    break; \
  default: \
    voidaction; \
    break; \
  }

  crypt_ctext (crypt_keytype _tag = (crypt_keytype) 0) : type (_tag)
    { _base.init (); set_type (_tag); }
  crypt_ctext (const crypt_ctext &_s)
    : type (_s.type)
    { _base.init (_s._base); }
  ~crypt_ctext () { _base.destroy (); }
  crypt_ctext &operator= (const crypt_ctext &_s) {
    const_cast<crypt_keytype &> (type) = _s.type;
    _base.assign (_s._base);
    return *this;
  }

  void set_type (crypt_keytype _tag) {
    const_cast<crypt_keytype &> (type) = _tag;
    rpcunion_switch_crypt_ctext
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, crypt_ctext &obj, const char *field = NULL)
{
  bool ret = true;
  rpc_enter_field (t, field);
  crypt_keytype tag = obj.type;
  if (!rpc_traverse (t, tag, "type")) { 
    ret = false;
  } else {
    if (tag != obj.type)
      obj.set_type (tag);

    rpcunion_switch_crypt_ctext
      (obj.type, ret = RPCUNION_TRAVERSE_2, ret = true, ret = false);
    /* gcc 4.0.3 makes buggy warnings without the following.. */
  }
  rpc_exit_field (t, field);
  return ret;
}
inline bool
rpc_traverse (const stompcast_t &s, crypt_ctext &obj, const char *field = NULL)
{
  rpcunion_switch_crypt_ctext
    (obj.type, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *crypt_ctext_alloc ();
bool_t xdr_crypt_ctext (XDR *, void *);
RPC_UNION_DECL (crypt_ctext)

/*
 *
 * MK note on RPC constant collection:
 *
 * The goal of this magic is to aggregate ALL of the RPC contants
 * in ALL of the .x files recursively included by your server
 * to be accessible at runtime to your server.  Thus, every
 * autogenerated .h protocol file will have one of these static
 * objects in it.  The static object itself doesn't do anything
 * other than call a constructor function, which in turn will
 * add this rpc_constant_collector_t hook (crypt_prot_constant_collect)
 * to a global list of hooks (see rpc_add_cch_t in extensible_arpc.C)
 *
 */
extern void crypt_prot_constant_collect (rpc_constant_collector_t *rcc);
static rpc_add_cch_t crypt_prot_obj (crypt_prot_constant_collect);

#endif /* !__RPCC_CRYPT_PROT_H_INCLUDED__ */
